/ {
    /* 
     * Let ZMK know which kscan device is the "keyboard" so it can
     * scan it. 
     */
    chosen {
        zmk,keyboard = &kscan0;
    };

    /* Example matrix setup for a 6x5, or 6x6, etc. Adjust for your real row/col count. */
    kscan0: kscan0 {
        compatible = "zmk,kscan-matrix-transform";
        label = "KSCAN0";

        /* Example: row-gpios. Adjust pin numbers for your board. */
        row-gpios = < &gpio0 3  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 4  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 5  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 6  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 7  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 8  (GPIO_ACTIVE_LOW) >;

        /* Example: col-gpios. Adjust pin numbers for your board. */
        col-gpios = < &gpio0 9  (GPIO_ACTIVE_LOW) >,
                    < &gpio0 10 (GPIO_ACTIVE_LOW) >,
                    < &gpio0 11 (GPIO_ACTIVE_LOW) >,
                    < &gpio0 12 (GPIO_ACTIVE_LOW) >,
                    < &gpio0 13 (GPIO_ACTIVE_LOW) >;

        diode-direction = "COL2ROW";

        #address-cells = <1>;
        #size-cells = <0>;

        /* 
         * The matrix transform is the arrangement of the keys in code.
         * Typically, you'd have something like 6 rows times 5 columns = 30
         * positions. This example is placeholder. 
         */
        zmk,matrix-transform = <
            0   1   2   3   4
            5   6   7   8   9
            10  11  12  13  14
            15  16  17  18  19
            20  21  22  23  24
            25  26  27  28  29
        >;
    };

    /*
     * If this is your "central" half, mark it as:
     *     zmk,split-role = "central";
     * If it's your "peripheral" half, mark it as:
     *     zmk,split-role = "peripheral";
     *
     * Typically we do separate overlays for left vs. right. For reference only:
     */
    zephyr,user {
        // For the left half, for example:
        // zmk,split-role = "central";
        
        // For the right half, for example:
        // zmk,split-role = "peripheral";
    };

    /* If you're using i2c1 for the display or other devices, enable and configure it */
    &i2c1 {
        status = "okay";

        /* Example nice!view for the OLED screen */
        nice_view: nice_view@3c {
            compatible = "nicekeyboards,nice-view";
            reg = <0x3C>;
            label = "NICE_VIEW";
            orientation-flip = "both"; /* or "vertical", "horizontal", etc. if needed */
        };
    };

    /*
     * Example definition for a single-wire WS2812 underglow LED strip.
     * Adjust the pin, chain length, color-order, etc. to match your board.
     */
    ws2812_u: ws2812_u {
        compatible = "worldsemi,ws2812";
        label = "WS2812_UNDERGLOW";
        chain-length = <30>;         /* or however many LEDs you have */
        // Example pin: P0.16, active drive
        gpios = < &gpio0 16 GPIO_OUTPUT >;
        color-order = "GRB";         /* or "RGB", "GRBW" if you have SK6812, etc. */
        power-supply = < &vdd >;     /* If you have an external supply, define it. */
        status = "okay";
    };

    /*
     * Example rotary encoder. In ZMK, you define it as a "behavior-rotary-encoder".
     * The "binding" property references the rotation CW and CCW behaviors in your keymap.
     */
    encoder0: encoder0 {
        compatible = "zmk,behavior-rotary-encoder";
        label = "ENCODER0";

        /* 
         * Example pins: P0.2 and P0.3 for A and B. 
         * Adjust them to the actual hardware pins. 
         */
        gpios = < &gpio0 2 (GPIO_ACTIVE_HIGH) >,
                < &gpio0 3 (GPIO_ACTIVE_HIGH) >;

        /* If there's also a push button on the encoder, you could define it as a separate switch in the matrix or a GPIO key. */
    };

    /*
     * Example directional joystick with 5 directions: up/down/left/right + center.
     * Often these are simply 5 separate switches that you can wire into your matrix or define as separate GPIO inputs. 
     * If your joystick is analog, you'll need an ADC approach, but that’s more advanced. 
     * For a “5-wire joystick,” you might do something like:
     */
    joystick0: joystick0 {
        compatible = "zmk,behavior-buttons";
        label = "JOYSTICK0";

        /* 
         * We'll pretend these are 5 discrete GPIO lines. If you’re using a matrix row or col, 
         * treat them as part of the matrix instead. 
         */
        gpios = < &gpio0 17 GPIO_ACTIVE_LOW >, /* up */
                < &gpio0 18 GPIO_ACTIVE_LOW >, /* down */
                < &gpio0 19 GPIO_ACTIVE_LOW >, /* left */
                < &gpio0 20 GPIO_ACTIVE_LOW >, /* right */
                < &gpio0 21 GPIO_ACTIVE_LOW >; /* center push */
    };
};

